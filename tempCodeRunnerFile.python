import ply.lex as lex
# List of token names 
tokens = (
'FOR', 'IN', 'RANGE', 'LPAREN', 'RPAREN', 'COLON', 'ID',
'NUMBER',
'PRINT', 'DEF', 'LBRACKET', 'RBRACKET', 'COMMA', 'EQUALS',
'STRING',
'PLUS', 'MINUS', 'TIMES', 'DIVIDE'
)
# Regular expression rules for simple tokens 
t_LPAREN = r'\('
t_RPAREN = r'\)' 
t_COLON = r':' 
t_LBRACKET = r'\[' 
t_RBRACKET = r'\]' 
t_COMMA = r',' 
t_EQUALS = r'=' 
t_PLUS = r'\+' 
t_MINUS = r'-' 
t_TIMES = r'\*'
t_DIVIDE = r'/'
# Dictionary of reserved words 
reserved = {
'for': 'FOR',
'in': 'IN',
'range': 'RANGE',
'print': 'PRINT',
'def': 'DEF'
}
def t_NUMBER(t):
    r'\d+'
    t.value = int(t.value)
    return t

def t_ID(t):
    r'[a-zA-Z_][a-zA-Z_0-9]*'
    t.type = reserved.get(t.value, 'ID')
    return t
def t_STRING(t): 
    r'\"([^\\\n]|(\\.))*?\"' 
    t.value = t.value[1:-1]
    return t

# Ignore spaces and tabs
t_ignore = ' \t'
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)
def t_error(t):
    print(f"Illegal character '{t.value[0]}'")
    t.lexer.skip(1)
# Build the lexer 
lexer = lex.lex()

import ply.yacc as yacc
# Flag to track if there's any syntax error
syntax_error = False
# Grammar rules 
def p_program(p):
    '''program : statement_list''' 
    global syntax_error
    if not syntax_error:
        print("Valid syntax")
    
def p_statement_list(p):
    '''statement_list : statement
    | statement_list statement'''
def p_statement(p):
    '''statement : for_loop
    | assignment
    | function_def
    | print_statement
    | expression'''
def p_assignment(p):
    '''assignment : ID EQUALS expression'''
def p_function_def(p):
    '''function_def : DEF ID LPAREN param_list RPAREN COLON''' 
    print(f"Function definition: {p[2]}")
def p_param_list(p):
    '''param_list : ID
    | ID COMMA param_list
    | empty'''
def p_for_loop(p):
    '''for_loop : FOR ID IN expression COLON'''
    
# Define precedence and associativity of operators
precedence = (
('left', 'PLUS', 'MINUS'), 
('left', 'TIMES', 'DIVIDE'),
)
def p_expression(p):
    '''expression : range_expr
    | list_expr
    | ID
    | NUMBER
    | STRING
    | expression PLUS expression
    | expression MINUS expression
    | expression TIMES expression
    | expression DIVIDE expression'''
    
def p_range_expr(p):
    '''range_expr : RANGE LPAREN range_params RPAREN'''
    
def p_range_params(p):
    '''range_params : expression
    | expression COMMA expression
    | expression COMMA expression COMMA expression'''
    
def p_list_expr(p):
    '''list_expr : LBRACKET list_items RBRACKET'''
def p_list_items(p):
    '''list_items : expression
    | expression COMMA list_items'''
    
def p_print_statement(p):
    '''print_statement : PRINT LPAREN expression RPAREN'''
def p_empty(p):
    '''empty :''' 
    pass

def p_error(p):
    global syntax_error 
    syntax_error = True 
    if p:
        print(f"Syntax error at '{p.value}' (Line {p.lineno}, Position {p.lexpos})")
    else:
        print("Syntax error at EOF")
        
parser = yacc.yacc()
if __name__ == "__main__":
    print("-----------------------------------------------------") 
    print("Enter your code (type 'end' on a new line to finish):") 
    print("-----------------------------------------------------") 
    code = ""
    while True:
        try:
            line = input()
            if line.strip().lower() == 'end':
                break
            code += line + '\n' 
        except EOFError:
            break
        
    syntax_error = False 
    parser.parse(code)